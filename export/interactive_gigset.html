<!DOCTYPE html><html>
    <head>
        <meta charset="utf-8">
        
            <script src="lib/bindings/utils.js"></script>
            <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/dist/vis-network.min.css" integrity="sha512-WgxfT5LWjfszlPHXRmBWHkV2eceiWTOBvrKCNbdgDYTHrT2AeLCGbF4sZlZw3UMN3WtL0tGUoIAKsu8mllg/XA==" crossorigin="anonymous" referrerpolicy="no-referrer" />
            <script src="https://cdnjs.cloudflare.com/ajax/libs/vis-network/9.1.2/dist/vis-network.min.js" integrity="sha512-LnvoEWDFrqGHlHmDD2101OrLcbsfkrzoSpvtSQtxK3RMnRV0eOkhhBN2dXHKRrUU8p2DGRTk35n4O8nWSVe1mQ==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
            
        
<center>
<h1></h1>
</center>

<!-- <link rel="stylesheet" href="../node_modules/vis/dist/vis.min.css" type="text/css" />
<script type="text/javascript" src="../node_modules/vis/dist/vis.js"> </script>-->
        <link
          href="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/css/bootstrap.min.css"
          rel="stylesheet"
          integrity="sha384-eOJMYsd53ii+scO/bJGFsiCZc+5NDVN2yr8+0RDqr0Ql0h+rP48ckxlpbzKgwra6"
          crossorigin="anonymous"
        />
        <script
          src="https://cdn.jsdelivr.net/npm/bootstrap@5.0.0-beta3/dist/js/bootstrap.bundle.min.js"
          integrity="sha384-JEW9xMcG8R+pH31jmWH6WWP0WintQrMb4s7ZOdauHnUtxwoG2vI5DkLtS3qm9Ekf"
          crossorigin="anonymous"
        ></script>


        <center>
          <h1></h1>
        </center>
        <style type="text/css">

             #mynetwork {
                 width: 100%;
                 height: 800px;
                 background-color: #1e1e1e;
                 border: 1px solid lightgray;
                 position: relative;
                 float: left;
             }

             

             
             #config {
                 float: left;
                 width: 400px;
                 height: 600px;
             }
             

             
        </style>
    </head>


    <body>
        <div class="card" style="width: 100%">
            
            
            <div id="mynetwork" class="card-body"></div>
        </div>

        
        
            <div id="config"></div>
        

        <script type="text/javascript">

              // initialize global variables.
              var edges;
              var nodes;
              var allNodes;
              var allEdges;
              var nodeColors;
              var originalNodes;
              var network;
              var container;
              var options, data;
              var filter = {
                  item : '',
                  property : '',
                  value : []
              };

              

              

              // This method is responsible for drawing the graph, returns the drawn network
              function drawGraph() {
                  var container = document.getElementById('mynetwork');

                  

                  // parsing and collecting nodes and edges from the python
                  nodes = new vis.DataSet([{"color": "#00bfff", "font": {"color": "white"}, "id": 1, "label": "D A D G B E", "shape": "dot", "size": 19, "songs_label": "Overlay by Antoine Dufour\nThe Nomad by Calum Graham", "tuning_label": "D A D G B E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 2, "label": "C E B E B E", "shape": "dot", "size": 17, "songs_label": "Phoenix Rising by Calum Graham", "tuning_label": "C E B E B E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 3, "label": "Db Ab Eb F Ab Eb", "shape": "dot", "size": 17, "songs_label": "Waiting by Calum Graham", "tuning_label": "Db Ab Eb F Ab Eb"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 4, "label": "F A C G C E", "shape": "dot", "size": 17, "songs_label": "Indivisible by Calum Graham", "tuning_label": "F A C G C E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 5, "label": "C F C F C C", "shape": "dot", "size": 17, "songs_label": "It is what it is by Calum Graham", "tuning_label": "C F C F C C"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 6, "label": "B G D E B C", "shape": "dot", "size": 17, "songs_label": "Three Way Street by Calum Graham", "tuning_label": "B G D E B C"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 7, "label": "D G D F# Ab D", "shape": "dot", "size": 17, "songs_label": "12:34 by Calum Graham", "tuning_label": "D G D F# Ab D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 8, "label": "D A C# D Ab Eb", "shape": "dot", "size": 17, "songs_label": "Tabula Rasa by Calum Graham", "tuning_label": "D A C# D Ab Eb"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 9, "label": "D G D G B Eb", "shape": "dot", "size": 17, "songs_label": "Farewell by Calum Graham", "tuning_label": "D G D G B Eb"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 10, "label": "E A D G B E", "shape": "dot", "size": 19, "songs_label": "South side of the Sky by Antoine Dufour\nWhiskey Sunrise by Calum Graham", "tuning_label": "E A D G B E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 11, "label": "B F# C# F# B F#", "shape": "dot", "size": 19, "songs_label": "Feeling Higher by Daniel Padim\nWaiting For You by Daniel Padim", "tuning_label": "B F# C# F# B F#"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 12, "label": "D A C G A E", "shape": "dot", "size": 17, "songs_label": "Pursuing the Horizon by Donovan Raitt", "tuning_label": "D A C G A E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 13, "label": "C G C G C E", "shape": "dot", "size": 19, "songs_label": "Auto Reverse by Antoine Dufour\nOcean by John Butler", "tuning_label": "C G C G C E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 14, "label": "C A D G B E", "shape": "dot", "size": 17, "songs_label": "Neon by John Mayer", "tuning_label": "C A D G B E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 15, "label": "A E B E G B", "shape": "dot", "size": 19, "songs_label": "Telepathy by Jon Gomm\nWujan Motorcycle Kid by Jon Gomm", "tuning_label": "A E B E G B"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 16, "label": "C A F C F A#", "shape": "dot", "size": 17, "songs_label": "Afterglow by Jon Gomm", "tuning_label": "C A F C F A#"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 17, "label": "F A C G A C", "shape": "dot", "size": 17, "songs_label": "Passionflower by Jon Gomm", "tuning_label": "F A C G A C"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 18, "label": "C G D G B D", "shape": "dot", "size": 17, "songs_label": "Orville by Jon Gomm", "tuning_label": "C G D G B D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 19, "label": "C G D G B E", "shape": "dot", "size": 19, "songs_label": "To Run in a Dream by Antoine Dufour\nThe Battle of WonderLand by Spencer Elliot", "tuning_label": "C G D G B E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 20, "label": "C G D G B C", "shape": "dot", "size": 17, "songs_label": "First Flight by Spencer Elliot", "tuning_label": "C G D G B C"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 21, "label": "D G D F A D", "shape": "dot", "size": 17, "songs_label": "Elipsos by Spencer Elliot", "tuning_label": "D G D F A D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 22, "label": "C G D G A# D", "shape": "dot", "size": 19, "songs_label": "Carousel by Spencer Elliot\nOff The Path by Tobias Rauscher", "tuning_label": "C G D G A# D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 23, "label": "B F# D F# B D", "shape": "dot", "size": 17, "songs_label": "Insignificant by Spencer Elliot", "tuning_label": "B F# D F# B D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 24, "label": "C E A D F# B", "shape": "dot", "size": 17, "songs_label": "Some Forgotten Color (Baritone) by Spencer Elliot", "tuning_label": "C E A D F# B"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 25, "label": "C G D F C E", "shape": "dot", "size": 17, "songs_label": "The Wolf and the Hawk by Spencer Elliot", "tuning_label": "C G D F C E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 26, "label": "A E C G A E", "shape": "dot", "size": 19, "songs_label": "Rain Shadow by Spencer Elliot\nThe Tournament by Spencer Elliot", "tuning_label": "A E C G A E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 27, "label": "G D A B D B", "shape": "dot", "size": 17, "songs_label": "Time Stands Still (Baritone) by Spencer Elliot", "tuning_label": "G D A B D B"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 28, "label": "C# G# C# E B D#", "shape": "dot", "size": 17, "songs_label": "Yin by Spencer Elliot", "tuning_label": "C# G# C# E B D#"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 29, "label": "C G C G A# C", "shape": "dot", "size": 17, "songs_label": "Torque by Spencer Elliot", "tuning_label": "C G C G A# C"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 30, "label": "A F C G B C", "shape": "dot", "size": 17, "songs_label": "Unspoken by Spencer Elliot", "tuning_label": "A F C G B C"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 31, "label": "D F# D F# A B", "shape": "dot", "size": 17, "songs_label": "On The Run by Tobias Rauscher", "tuning_label": "D F# D F# A B"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 32, "label": "Eb Bb D G B F", "shape": "dot", "size": 17, "songs_label": "Hutton Drive by Tobias Rauscher", "tuning_label": "Eb Bb D G B F"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 33, "label": "Eb G D G Bb D", "shape": "dot", "size": 17, "songs_label": "Memories by Tobias Rauscher", "tuning_label": "Eb G D G Bb D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 34, "label": "C G C G C D", "shape": "dot", "size": 17, "songs_label": "Acousticore by Tobias Rauscher", "tuning_label": "C G C G C D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 35, "label": "E C D G A D", "shape": "dot", "size": 17, "songs_label": "Coming Home by Tobias Rauscher", "tuning_label": "E C D G A D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 36, "label": "D# G D G A# D", "shape": "dot", "size": 17, "songs_label": "Still Awake by Tobias Rauscher", "tuning_label": "D# G D G A# D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 37, "label": "E A D G B D", "shape": "dot", "size": 17, "songs_label": "Perspectives by Tobias Rauscher", "tuning_label": "E A D G B D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 38, "label": "C G C D G C", "shape": "dot", "size": 17, "songs_label": "The Future by Luca Stricagnoli", "tuning_label": "C G C D G C"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 39, "label": "B F# C# D A D", "shape": "dot", "size": 19, "songs_label": "Encomium (Reverie) by Mike Dawes\nThe Old Room by Mike Dawes", "tuning_label": "B F# C# D A D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 40, "label": "A# A# D# F A# D#", "shape": "dot", "size": 17, "songs_label": "Boogie Slam by Mike Dawes", "tuning_label": "A# A# D# F A# D#"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 41, "label": "C# G# C# F# G# C#", "shape": "dot", "size": 17, "songs_label": "Overload by Mike Dawes", "tuning_label": "C# G# C# F# G# C#"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 42, "label": "C A D G A D", "shape": "dot", "size": 17, "songs_label": "Somebody That I Used To Know by Mike Dawes", "tuning_label": "C A D G A D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 43, "label": "Eb Bb C G Bb D", "shape": "dot", "size": 19, "songs_label": "Air Ground by Antoine Dufour\nElectromagnetic Sun Powered Starship by Antoine Dufour", "tuning_label": "Eb Bb C G Bb D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 44, "label": "C# G# E F# B D#", "shape": "dot", "size": 17, "songs_label": "Deja Vu by Antoine Dufour", "tuning_label": "C# G# E F# B D#"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 45, "label": "D A E F C E", "shape": "dot", "size": 17, "songs_label": "Drowning by Antoine Dufour", "tuning_label": "D A E F C E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 46, "label": "E A C G B D", "shape": "dot", "size": 17, "songs_label": "Lost in Your Eyes by Antoine Dufour", "tuning_label": "E A C G B D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 47, "label": "E A C G B E", "shape": "dot", "size": 17, "songs_label": "Spirits in the Material World by Antoine Dufour", "tuning_label": "E A C G B E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 48, "label": "D A E F# C# D", "shape": "dot", "size": 17, "songs_label": "In my Own Rhythms by Antoine Dufour", "tuning_label": "D A E F# C# D"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 49, "label": "D A E G# A E", "shape": "dot", "size": 17, "songs_label": "Hide and Seek by Antoine Dufour", "tuning_label": "D A E G# A E"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 50, "label": "F Ab C Db Bb F", "shape": "dot", "size": 17, "songs_label": "So Little While Road by Antoine Dufour", "tuning_label": "F Ab C Db Bb F"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 51, "label": "Eb Bb D Eb Bb F", "shape": "dot", "size": 17, "songs_label": "The Drive Within by Antoine Dufour", "tuning_label": "Eb Bb D Eb Bb F"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 52, "label": "C# G# E G# C# D#", "shape": "dot", "size": 17, "songs_label": "Cold Day by Antoine Dufour", "tuning_label": "C# G# E G# C# D#"}, {"color": "#00bfff", "font": {"color": "white"}, "id": 53, "label": "C# A B G# B E", "shape": "dot", "size": 17, "songs_label": "Life in Technicolor by Antoine Dufour", "tuning_label": "C# A B G# B E"}]);
                  edges = new vis.DataSet([{"color": "#aaaaaa", "from": 1, "pitch_vector": "-2,0,0,0,0,0", "to": 14}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "-2,-2,0,0,0,0", "to": 19}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "0,0,0,-2,1,0", "to": 28}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "0,0,0,0,-2,-2", "to": 41}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "0,0,-2,0,-2,0", "to": 12}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "2,0,2,0,0,0", "to": 21}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "0,-2,0,0,0,-1", "to": 9}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "2,0,-2,0,0,0", "to": 47}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "2,0,0,0,0,-2", "to": 37}, {"color": "#aaaaaa", "from": 1, "pitch_vector": "2,0,0,0,0,0", "to": 10}, {"color": "#aaaaaa", "from": 3, "pitch_vector": "0,0,0,2,0,0", "to": 49}, {"color": "#aaaaaa", "from": 3, "pitch_vector": "0,0,0,0,0,2", "to": 27}, {"color": "#aaaaaa", "from": 4, "pitch_vector": "0,0,2,0,-1,0", "to": 24}, {"color": "#aaaaaa", "from": 4, "pitch_vector": "-1,0,0,0,-1,0", "to": 47}, {"color": "#aaaaaa", "from": 6, "pitch_vector": "1,0,0,0,0,0", "to": 48}, {"color": "#aaaaaa", "from": 7, "pitch_vector": "-2,0,0,0,-1,0", "to": 49}, {"color": "#aaaaaa", "from": 7, "pitch_vector": "0,0,0,-1,1,0", "to": 21}, {"color": "#aaaaaa", "from": 8, "pitch_vector": "0,0,0,0,1,1", "to": 51}, {"color": "#aaaaaa", "from": 9, "pitch_vector": "-2,0,0,0,0,-1", "to": 18}, {"color": "#aaaaaa", "from": 9, "pitch_vector": "-2,0,0,0,0,1", "to": 19}, {"color": "#aaaaaa", "from": 10, "pitch_vector": "1,0,0,0,0,0", "to": 24}, {"color": "#aaaaaa", "from": 10, "pitch_vector": "0,0,2,0,0,0", "to": 21}, {"color": "#aaaaaa", "from": 10, "pitch_vector": "0,0,-2,0,0,-2", "to": 46}, {"color": "#aaaaaa", "from": 10, "pitch_vector": "0,0,-2,0,0,0", "to": 47}, {"color": "#aaaaaa", "from": 10, "pitch_vector": "0,0,0,0,0,-2", "to": 37}, {"color": "#aaaaaa", "from": 12, "pitch_vector": "0,0,2,0,0,-2", "to": 41}, {"color": "#aaaaaa", "from": 12, "pitch_vector": "2,0,0,0,2,0", "to": 47}, {"color": "#aaaaaa", "from": 13, "pitch_vector": "0,0,0,0,0,-2", "to": 34}, {"color": "#aaaaaa", "from": 13, "pitch_vector": "0,0,2,-2,0,0", "to": 25}, {"color": "#aaaaaa", "from": 13, "pitch_vector": "0,0,2,0,-1,0", "to": 19}, {"color": "#aaaaaa", "from": 14, "pitch_vector": "0,0,0,0,-2,-2", "to": 42}, {"color": "#aaaaaa", "from": 14, "pitch_vector": "0,-2,0,0,0,-2", "to": 18}, {"color": "#aaaaaa", "from": 14, "pitch_vector": "0,-2,0,0,0,0", "to": 19}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,2,0,0,-1,0", "to": 42}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,-2,0,0,-2", "to": 29}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,-2,0,2,0", "to": 34}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,0,0,0,0", "to": 22}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,0,0,1,-2", "to": 20}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,0,0,1,0", "to": 18}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,0,0,1,2", "to": 19}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,1,-2,0,0", "to": 44}, {"color": "#aaaaaa", "from": 15, "pitch_vector": "0,0,1,0,2,0", "to": 52}, {"color": "#aaaaaa", "from": 18, "pitch_vector": "0,2,0,0,-2,0", "to": 42}, {"color": "#aaaaaa", "from": 18, "pitch_vector": "0,0,-2,0,1,0", "to": 34}, {"color": "#aaaaaa", "from": 18, "pitch_vector": "0,0,0,0,-1,0", "to": 22}, {"color": "#aaaaaa", "from": 18, "pitch_vector": "0,0,0,0,0,-2", "to": 20}, {"color": "#aaaaaa", "from": 18, "pitch_vector": "0,0,0,0,0,2", "to": 19}, {"color": "#aaaaaa", "from": 18, "pitch_vector": "0,0,1,0,1,0", "to": 52}, {"color": "#aaaaaa", "from": 19, "pitch_vector": "0,0,0,-2,1,0", "to": 25}, {"color": "#aaaaaa", "from": 19, "pitch_vector": "0,0,0,0,-1,-2", "to": 22}, {"color": "#aaaaaa", "from": 20, "pitch_vector": "0,0,-2,0,-1,0", "to": 29}, {"color": "#aaaaaa", "from": 20, "pitch_vector": "0,0,0,0,-1,2", "to": 22}, {"color": "#aaaaaa", "from": 21, "pitch_vector": "1,0,-2,0,0,0", "to": 24}, {"color": "#aaaaaa", "from": 21, "pitch_vector": "0,2,0,-1,0,0", "to": 38}, {"color": "#aaaaaa", "from": 21, "pitch_vector": "0,2,0,2,0,0", "to": 41}, {"color": "#aaaaaa", "from": 21, "pitch_vector": "0,0,-2,0,0,-2", "to": 37}, {"color": "#aaaaaa", "from": 22, "pitch_vector": "0,2,0,0,-1,0", "to": 42}, {"color": "#aaaaaa", "from": 22, "pitch_vector": "0,0,-2,0,0,-2", "to": 29}, {"color": "#aaaaaa", "from": 22, "pitch_vector": "0,0,-2,0,2,0", "to": 34}, {"color": "#aaaaaa", "from": 22, "pitch_vector": "0,0,1,-2,0,0", "to": 44}, {"color": "#aaaaaa", "from": 22, "pitch_vector": "0,0,1,0,2,0", "to": 52}, {"color": "#aaaaaa", "from": 23, "pitch_vector": "0,0,0,0,0,-1", "to": 52}, {"color": "#aaaaaa", "from": 24, "pitch_vector": "-1,0,-2,0,0,0", "to": 47}, {"color": "#aaaaaa", "from": 24, "pitch_vector": "-1,0,0,0,0,-2", "to": 37}, {"color": "#aaaaaa", "from": 25, "pitch_vector": "2,2,0,0,0,0", "to": 28}, {"color": "#aaaaaa", "from": 27, "pitch_vector": "0,0,0,2,0,-2", "to": 49}, {"color": "#aaaaaa", "from": 28, "pitch_vector": "0,0,2,0,0,1", "to": 39}, {"color": "#aaaaaa", "from": 28, "pitch_vector": "0,0,2,0,0,0", "to": 45}, {"color": "#aaaaaa", "from": 29, "pitch_vector": "0,0,0,0,2,2", "to": 34}, {"color": "#aaaaaa", "from": 31, "pitch_vector": "0,0,-1,0,0,2", "to": 36}, {"color": "#aaaaaa", "from": 31, "pitch_vector": "0,0,-1,0,0,2", "to": 33}, {"color": "#aaaaaa", "from": 33, "pitch_vector": "0,0,0,0,0,0", "to": 36}, {"color": "#aaaaaa", "from": 37, "pitch_vector": "-2,0,0,0,-2,0", "to": 41}, {"color": "#aaaaaa", "from": 37, "pitch_vector": "0,0,-2,0,0,0", "to": 46}, {"color": "#aaaaaa", "from": 37, "pitch_vector": "0,0,-2,0,0,2", "to": 47}, {"color": "#aaaaaa", "from": 39, "pitch_vector": "0,0,0,0,0,-1", "to": 45}, {"color": "#aaaaaa", "from": 41, "pitch_vector": "-2,0,0,0,0,0", "to": 42}, {"color": "#aaaaaa", "from": 44, "pitch_vector": "0,0,0,2,2,0", "to": 52}, {"color": "#aaaaaa", "from": 44, "pitch_vector": "0,0,-1,-2,0,0", "to": 45}, {"color": "#aaaaaa", "from": 46, "pitch_vector": "0,0,0,0,0,2", "to": 47}]);

                  nodeColors = {};
                  allNodes = nodes.get({ returnType: "Object" });
                  for (nodeId in allNodes) {
                    nodeColors[nodeId] = allNodes[nodeId].color;
                  }
                  allEdges = edges.get({ returnType: "Object" });
                  // adding nodes and edges to the graph
                  data = {nodes: nodes, edges: edges};

                  var options = {
    "configure": {
        "enabled": true,
        "filter": [
            "physics"
        ]
    },
    "edges": {
        "color": {
            "inherit": true
        },
        "smooth": {
            "enabled": true,
            "type": "dynamic"
        }
    },
    "interaction": {
        "dragNodes": true,
        "hideEdgesOnDrag": false,
        "hideNodesOnDrag": false
    },
    "physics": {
        "enabled": true,
        "stabilization": {
            "enabled": true,
            "fit": true,
            "iterations": 1000,
            "onlyDynamicEdges": false,
            "updateInterval": 50
        }
    }
};

                  


                  
                  // if this network requires displaying the configure window,
                  // put it in its div
                  options.configure["container"] = document.getElementById("config");
                  

                  network = new vis.Network(container, data, options);

                  

                  

                  


                  

                  return network;

              }
              drawGraph();
        </script>
    <script>// =====================================================
// Global State and Configuration
// =====================================================

/**
 * Stores the currently selected path of tunings in the gigset.
 * Each element is a node ID corresponding to a tuning.
 */
let gigsetPath = [];

/**
 * UI color settings for different node states in the graph.
 */
let highlightColor = '#90ee90';    // Green ‚Äì valid adjacent nodes
let selectedColor = '#ff69b4';     // Pink ‚Äì selected nodes in gigset
let defaultColor = '#00bfff';      // Blue ‚Äì unselected nodes

/**
 * Determines whether song labels or tuning labels are shown.
 * true ‚Üí show song names, false ‚Üí show tuning pitches.
 */
let showSongs = false;

/**
 * User-defined pitch constraints (in MIDI numbers) for each string.
 * These arrays define the allowed pitch range for each string in the tuning.
 * String order: [Low E, A, D, G, B, High E]
 * 
 * Example:
 *   E2 = 40, so 40-4 = 36 means Low E must be at least C#2
 */
const minPitchPerString = [36, 41, 46, 51, 55, 60];
const maxPitchPerString = [40, 45, 50, 55, 59, 64];

/**
 * Maps semitone offsets to note names for MIDI conversion.
 * Index 0 = C, 1 = C#, ..., 11 = B
 */
const NOTE_NAMES = [
    "C", "C#", "D", "D#", "E", "F",
    "F#", "G", "G#", "A", "A#", "B"
];


/**
 * Converts a MIDI pitch number into a human-readable note name with octave.
 *
 * For example:
 *   midiToNote(40) ‚Üí "E2"
 *   midiToNote(64) ‚Üí "E4"
 *
 * @param {number} midiNumber - The MIDI pitch number (e.g., 60 = Middle C).
 * @returns {string} The corresponding note name with octave (e.g., "C4").
 */
function midiToNote(midiNumber) {
    const note = NOTE_NAMES[midiNumber % 12];
    const octave = Math.floor(midiNumber / 12) - 1;
    return note + octave;
}


/**
 * Converts a musical note (e.g., "E2", "C#4", "Bb3") into its corresponding MIDI pitch number.
 *
 * MIDI numbers range from 0 (C-1) to 127 (G9). This function parses both sharp (#) and flat (b)
 * accidentals and supports negative and positive octave values.
 *
 * For example:
 *   noteToMidi("C4") ‚Üí 60
 *   noteToMidi("A#3") ‚Üí 58
 *   noteToMidi("Eb2") ‚Üí 39
 *
 * @param {string} note - The note string in scientific pitch notation.
 * @returns {number|null} The MIDI pitch number, or null if the input is invalid.
 */
function noteToMidi(note) {
    const match = /^([A-Ga-g])([#b]?)(-?\d+)$/.exec(note.trim());
    if (!match) return null;

    let [, letter, accidental, octaveStr] = match;
    letter = letter.toUpperCase();
    const octave = parseInt(octaveStr);

    let semitoneOffset = {
        C: 0, D: 2, E: 4, F: 5, G: 7, A: 9, B: 11
    }[letter];

    if (accidental === "#") semitoneOffset += 1;
    if (accidental === "b") semitoneOffset -= 1;

    return (octave + 1) * 12 + semitoneOffset;
}



/**
 * Returns a list of node IDs directly connected to the given node.
 *
 * This function looks at all edges connected to the specified node in the Vis.js network
 * and identifies the nodes on the other end of each edge, ensuring that undirected connections
 * are handled symmetrically.
 *
 * @param {string|number} nodeId - The ID of the node to find neighbors for.
 * @returns {Array<string|number>} An array of adjacent node IDs.
 */
function getAdjacentNodes(nodeId) {
    const connectedEdges = network.getConnectedEdges(nodeId);
    const adjacent = new Set();

    connectedEdges.forEach(edgeId => {
        const edge = network.body.edges[edgeId];
        const { from, to } = edge;

        if (from.id === nodeId) adjacent.add(to.id);
        else if (to.id === nodeId) adjacent.add(from.id);
    });

    return Array.from(adjacent);
}


// Cache for absolute pitch values corresponding to each tuning in gigsetPath
let cachedAbsolutePitches = [];

/**
 * Updates the node highlighting in the network graph based on the current gigset path.
 * This function recalculates the pitch values for tunings along the gigset path, adjusts the
 * node colors depending on their adjacency to the path, and updates edge highlighting.
 */
function updateHighlighting() {
    // Retrieve all nodes in the graph
    const allNodes = network.body.data.nodes.get();

    // Simulate absolute pitches along the gigset path
    cachedAbsolutePitches = simulateAbsolutePitches(gigsetPath) || [];

    // Warn if no pitches were computed despite the gigsetPath existing
    if (cachedAbsolutePitches.length === 0 && gigsetPath.length > 0) {
        console.warn("üö® No pitches computed despite gigsetPath existing!");
    }

    // Map node IDs to their corresponding pitch sets
    const pitchMap = {};
    gigsetPath.forEach((id, i) => {
        pitchMap[id] = cachedAbsolutePitches[i];
    });

    // Update node colors and labels based on their state (selected or adjacent to the path)
    const updatedNodes = allNodes.map((node) => {
        const id = node.id;
        let color = defaultColor; // Default color for nodes
        let label = showSongs ? node.songs_label : node.tuning_label || node.label;
        let font = { color: "white" }; // Default font color

        // Check if the node is selected or adjacent to the path
        const isSelected = gigsetPath.includes(id);
        const isAdjacent = gigsetPath.length === 0 || getAdjacentNodes(gigsetPath[gigsetPath.length - 1]).includes(id);

        // Apply colors and labels for selected nodes
        if (isSelected) {
            color = selectedColor; // Highlight selected node with a special color

            // Update label for selected node to display the absolute pitches in note form
            if (!showSongs) {
                const pitchSet = pitchMap[id];
                if (pitchSet && pitchSet.length === 6 && pitchSet.every(n => !isNaN(n))) {
                    label = pitchSet.map(midiToNote).join(" ");
                    font = { color: selectedColor, bold: true }; // Bold font for selected node
                } else {
                    console.warn("‚ö†Ô∏è Invalid or missing pitch set for node", id, pitchSet);
                }
            }
        } else {
            // Handle unselected nodes, setting color based on adjacency and constraints
            if (!isAdjacent) {
                color = defaultColor; // Blue for non-adjacent nodes
            } else if (canAddNode(id)) {
                color = highlightColor; // Green for adjacent and allowed nodes
            } else {
                color = '#aaaaaa'; // Grey for blocked nodes
            }

            // Reset font to white if it's not a selected node
            if (!showSongs) {
                font = { color: "white" };
            }
        }

        return { id, color, label, font };
    });

    // Update node data with new colors and labels
    network.body.data.nodes.update(updatedNodes);

    // Update edge colors based on whether they are part of the gigset path
    const allEdges = network.body.data.edges.get();
    const updatedEdges = allEdges.map(edge => {
        const fromIndex = gigsetPath.indexOf(edge.from);
        const toIndex = gigsetPath.indexOf(edge.to);
        const isConsecutive = Math.abs(fromIndex - toIndex) === 1;
        const isInPath = fromIndex !== -1 && toIndex !== -1 && isConsecutive;
        return {
            id: edge.id,
            color: isInPath ? { color: '#ff69b4', highlight: '#ff1493' } : { color: '#848484' }
        };
    });
    network.body.data.edges.update(updatedEdges);

    // Add a numbering overlay on the nodes to show the order in the path
    network.on("afterDrawing", () => {
        const canvas = network.canvas.frame.canvas;
        const ctx = canvas.getContext("2d");
        ctx.font = "bold 16px Arial";
        ctx.fillStyle = "black";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        gigsetPath.forEach((nodeId, i) => {
            const pos = network.getPositions([nodeId])[nodeId];
            ctx.fillText(i + 1, pos.x, pos.y);
        });
    });
}


/**
 * Handles a click on a node in the network graph. Allows selecting and deselecting nodes
 * based on adjacency and constraint validation.
 */
function handleGigsetClick(params) {
    if (params.nodes.length > 0) {
        const nodeId = params.nodes[0];

        // Allow undoing the last node if it's already in the gigset path
        if (gigsetPath[gigsetPath.length - 1] === nodeId) {
            gigsetPath.pop();
        } 
        // Add node to gigsetPath if it's adjacent and satisfies the constraints
        else if (
            !gigsetPath.includes(nodeId) &&
            (gigsetPath.length === 0 || getAdjacentNodes(gigsetPath[gigsetPath.length - 1]).includes(nodeId)) &&
            canAddNode(nodeId)
        ) {
            gigsetPath.push(nodeId);
        }

        // Recalculate highlighting based on the updated gigset path
        updateHighlighting();
    }
}


/**
 * Displays the current gigset tunings in an alert message.
 * This function is triggered when the user wants to view the path of selected tunings.
 */
function showGigset() {
    // Show the tunings in the gigset path as a string in the format: "Tuning1 -> Tuning2 -> ..."
    alert("Gigset Tunings: " + gigsetPath.join(" -> "));
}


/**
 * Resets the gigset path by clearing the current sequence of tunings,
 * updating the highlighting of nodes, and redrawing the network to reflect the changes.
 */
function resetGigset() {
    // Clear the current gigset path
    gigsetPath = [];

    // Update the node and edge highlighting based on the empty gigset path
    updateHighlighting();

    // Redraw the network visualization to reflect the reset state
    network.redraw();
}


/**
 * Toggles the visibility of the song labels on the nodes in the network graph.
 * This function switches between displaying song names or tuning labels, depending
 * on the current state, and triggers an update to the node highlighting.
 */
function toggleLabels() {
    // Toggle the showSongs flag between true and false
    showSongs = !showSongs;

    // Update the node highlighting based on the new state of showSongs
    updateHighlighting();
}


/**
 * Sets up the network click handler and UI elements like buttons for interaction.
 * This includes setting up buttons for showing the gigset, resetting the gigset,
 * toggling the song labels, and displaying the pitch constraint panel.
 */

// Add click handler for the network graph (for selecting nodes)
network.on("click", handleGigsetClick);

// Create and style the "Show Gigset" button
const showBtn = document.createElement("button");
showBtn.innerHTML = "Show Gigset";
showBtn.style.position = "absolute";
showBtn.style.top = "10px";
showBtn.style.left = "10px";
showBtn.style.zIndex = 9999;
showBtn.onclick = showGigset; // Trigger showing the current gigset
document.body.appendChild(showBtn);

// Create and style the "Reset Gigset" button
const resetBtn = document.createElement("button");
resetBtn.innerHTML = "Reset Gigset";
resetBtn.style.position = "absolute";
resetBtn.style.top = "50px";
resetBtn.style.left = "10px";
resetBtn.style.zIndex = 9999;
resetBtn.onclick = resetGigset; // Trigger resetting the gigset
document.body.appendChild(resetBtn);

// Create and style the "Toggle Song Labels" button
const toggleBtn = document.createElement("button");
toggleBtn.innerHTML = "Toggle Song Labels";
toggleBtn.style.position = "absolute";
toggleBtn.style.top = "90px";
toggleBtn.style.left = "10px";
toggleBtn.style.zIndex = 9999;
toggleBtn.onclick = toggleLabels; // Toggle between showing songs or tunings
document.body.appendChild(toggleBtn);

// Create and style the panel for pitch constraints
const constraintPanel = document.createElement("div");
constraintPanel.style.position = "absolute";
constraintPanel.style.top = "140px";
constraintPanel.style.left = "10px";
constraintPanel.style.backgroundColor = "white";
constraintPanel.style.border = "1px solid #ccc";
constraintPanel.style.padding = "10px";
constraintPanel.style.zIndex = 9999;

// Add title to the constraints panel
constraintPanel.innerHTML = "<b>Pitch Constraints</b><br>";

// Create string labels for pitch constraint inputs
const stringLabels = ["6 (Low E)", "5 (A)", "4 (D)", "3 (G)", "2 (B)", "1 (High E)"];
const minInputs = [];
const maxInputs = [];


/**
 * Creates and appends input elements for adjusting the pitch constraints
 * of the guitar strings. Each string has a minimum and maximum pitch value
 * that can be adjusted, and any invalid input is visually indicated.
 */
for (let i = 0; i < 6; i++) {
    // Create a label for the current string
    const label = document.createElement("div");
    label.innerText = `String ${stringLabels[i]}:`;

    // Create and set up the minimum pitch input field
    const minInput = document.createElement("input");
    minInput.type = "text";
    minInput.value = midiToNote(minPitchPerString[i]); // Set the initial value
    minInput.style.width = "60px"; // Set input field width
    minInput.onchange = () => {
        const midi = noteToMidi(minInput.value); // Convert the input to MIDI
        if (midi !== null) {
            // Update the min pitch value if valid
            minPitchPerString[i] = midi;
            minInput.style.borderColor = ""; // Reset border color to default
            updateHighlighting(); // Recalculate and update highlighting
        } else {
            // If invalid input, highlight the field in red
            minInput.style.borderColor = "red";
        }
    };

    // Create and set up the maximum pitch input field
    const maxInput = document.createElement("input");
    maxInput.type = "text";
    maxInput.value = midiToNote(maxPitchPerString[i]); // Set the initial value
    maxInput.style.width = "60px"; // Set input field width
    maxInput.onchange = () => {
        const midi = noteToMidi(maxInput.value); // Convert the input to MIDI
        if (midi !== null) {
            // Update the max pitch value if valid
            maxPitchPerString[i] = midi;
            maxInput.style.borderColor = ""; // Reset border color to default
            updateHighlighting(); // Recalculate and update highlighting
        } else {
            // If invalid input, highlight the field in red
            maxInput.style.borderColor = "red";
        }
    };

    // Create a container (row) for the min and max input fields
    const row = document.createElement("div");
    row.style.marginBottom = "4px"; // Add some space between rows
    row.appendChild(label); // Add string label to the row
    row.appendChild(document.createTextNode("Min: ")); // Add "Min: " text
    row.appendChild(minInput); // Add the minimum pitch input field
    row.appendChild(document.createTextNode(" Max: ")); // Add "Max: " text
    row.appendChild(maxInput); // Add the maximum pitch input field

    // Append the row to the constraint panel
    constraintPanel.appendChild(row);
}

// Append the complete constraint panel to the document body
document.body.appendChild(constraintPanel);

// Initial color setup
network.once("afterDrawing", updateHighlighting);


/**
 * Retrieves the pitch vector representing the transposition from one tuning to another.
 * The pitch vector indicates how each string needs to be transposed to move from one tuning to another.
 * Assumes that edges are directed FROM ‚Üí TO.
 *
 * @param {string} fromId - The ID of the starting tuning node.
 * @param {string} toId - The ID of the destination tuning node.
 * @returns {Array|null} - The pitch vector as an array of numbers, or null if no valid edge exists.
 */
function getPitchVector(fromId, toId) {
    try {
        // Find the edge connecting the two nodes (fromId to toId)
        const edgeId = network.getConnectedEdges(fromId).find(eid => {
            const edge = network.body.data.edges.get(eid);
            return (
                (edge.from === fromId && edge.to === toId) ||
                (edge.to === fromId && edge.from === toId)
            );
        });

        // If no edge is found, return null
        if (!edgeId) {
            return null;
        }

        const edge = network.body.data.edges.get(edgeId);
        const raw = edge.pitch_vector;

        // If there's no pitch_vector, return null
        if (!raw) {
            return null;
        }

        // Convert the raw pitch vector string into an array of numbers
        const vector = raw.split(',').map(Number);

        // Ensure the direction of the pitch vector is FROM ‚Üí TO
        return (edge.from === fromId) ? vector : vector.map(x => -x);
    } catch (err) {
        // Handle errors that occur during the process
        return null;
    }
}


/**
 * Simulates the absolute pitches along the given path of tunings.
 * The function calculates the transposition needed to fit each tuning within specified pitch constraints.
 *
 * @param {Array} path - The array of node IDs representing the gigset path.
 * @returns {Array|null} - The array of absolute pitches for each tuning in the path, or null if the path is invalid.
 */
function simulateAbsolutePitches(path) {
    const pitches = [];

    // Retrieve the first node's tuning label
    const node = network.body.data.nodes.get(path[0]);
    if (!node || !node.tuning_label) {
        return null; // Return null if tuning information is missing
    }

    // Parse the relative tuning from the node's tuning label
    let relativeTuning = parseMonotonicTuning(node.tuning_label);
    if (!relativeTuning) return null;

    // Determine the maximum transposition T that fits within the constraints for all strings
    let lower = -Infinity;
    let upper = Infinity;
    for (let i = 0; i < 6; i++) {
        const t_i = relativeTuning[i];
        const low = minPitchPerString[i] - t_i;
        const high = maxPitchPerString[i] - t_i;
        lower = Math.max(lower, low);
        upper = Math.min(upper, high);
    }

    // If the constraints make transposition impossible, return null
    if (lower > upper) {
        return null;
    }

    // Select the maximum transposition T that fits
    const transposition = Math.floor(upper);
    let current = relativeTuning.map(x => x + transposition);
    pitches.push([...current]);

    // Iterate over the path to apply pitch changes from one node to the next
    for (let i = 1; i < path.length; i++) {
        const fromId = path[i - 1];
        const toId = path[i];
        const vector = getPitchVector(fromId, toId);
        if (!vector) {
            return null; // Return null if no valid pitch vector is found
        }
    
        // Apply the pitch vector to adjust the tuning
        current = current.map((p, idx) => p + vector[idx]);
        pitches.push([...current]);
    }

    return pitches; // Return the computed absolute pitches for the path
}


/**
 * Validates if a sequence of tunings in the gigset path satisfies the pitch constraints.
 * The function checks if the sequence of tunings can be transposed such that all tunings fit
 * within the specified minimum and maximum pitch constraints for each string.
 *
 * @param {Array} pitches - An array of tunings, each represented as an array of pitch values for the strings.
 * @returns {boolean} - Returns `true` if the transposition is possible within the constraints, `false` otherwise.
 */
function isTranspositionPossible(pitches) {
    // Check if any tuning simulation failed (i.e., contains null values)
    if (pitches.some(p => p === null)) {
        console.warn("‚ö†Ô∏è One or more tunings failed to simulate. Aborting constraint check.");
        return false;
    }

    let globalLowerBound = -Infinity;
    let globalUpperBound = Infinity;

    // Iterate through each string and check if the tuning is within allowed bounds
    for (let stringIdx = 0; stringIdx < 6; stringIdx++) {
        const stringPitches = pitches.map(tuning => tuning[stringIdx]);

        // For each pitch of a string, calculate the transposition window
        for (const pitch of stringPitches) {
            const lower = minPitchPerString[stringIdx] - pitch;
            const upper = maxPitchPerString[stringIdx] - pitch;

            // Update global bounds based on this string's pitch constraints
            globalLowerBound = Math.max(globalLowerBound, lower);
            globalUpperBound = Math.min(globalUpperBound, upper);
        }
    }

    // Check if the transposition window is valid
    return globalLowerBound <= globalUpperBound;
}


/**
 * Determines whether a node can be added to the gigset path based on adjacency and pitch constraints.
 * The function checks if the node is adjacent to the last node in the path, simulates the absolute pitches
 * along the updated path, and validates if the path satisfies the pitch constraints.
 *
 * @param {string} candidateId - The ID of the node to potentially add to the gigset path.
 * @returns {boolean} - Returns `true` if the node can be added to the gigset path, `false` otherwise.
 */
function canAddNode(candidateId) {
    // Allow the first node to be added regardless of constraints
    if (gigsetPath.length === 0) {
        return true;
    }

    const lastId = gigsetPath[gigsetPath.length - 1];
    const isAdjacent = getAdjacentNodes(lastId).includes(candidateId);

    // If the node is not adjacent, it cannot be added to the path
    if (!isAdjacent) {
        return false;
    }

    // Simulate the path with the candidate node added
    const simulatedPath = [...gigsetPath, candidateId];
    const pitches = simulateAbsolutePitches(simulatedPath);

    // If the simulation fails (returns null), the node is not valid
    if (!pitches) {
        return false;
    }

    // Validate if the path satisfies the pitch constraints
    const result = isTranspositionPossible(pitches);
    return result;
}


/**
 * Parses a tuning label (e.g., "E A D G B E") into a list of absolute pitch values, ensuring
 * that the tuning is in ascending order of pitch. This function converts the note names into
 * MIDI values and calculates the correct octaves to maintain a monotonically increasing pitch sequence.
 *
 * @param {string} tuningLabel - The tuning label as a space-separated string (e.g., "E A D G B E").
 * @returns {Array<number>|null} - Returns an array of absolute pitch values or null if the parsing fails.
 */
function parseMonotonicTuning(tuningLabel) {
    // Split the tuning label into individual notes and convert to MIDI values
    const rawNotes = tuningLabel.trim().split(/\s+/);
    let pitchClasses = [];

    // Convert each note to its corresponding pitch class (mod 12)
    for (let note of rawNotes) {
        const midi = noteToMidi(note + "0");
        if (midi === null) {
            // If an invalid note is found, return null
            return null;
        }
        pitchClasses.push(midi % 12);
    }

    // Calculate the absolute pitch values while maintaining ascending order
    let pitches = [];
    let prev = -Infinity;

    for (let pc of pitchClasses) {
        let octave = 0;

        // Ensure that each note is higher than the previous one by adjusting octaves
        while ((octave * 12 + pc) <= prev) {
            octave++;
        }

        let midiPitch = octave * 12 + pc;
        pitches.push(midiPitch);
        prev = midiPitch;
    }

    return pitches;
}
</script></body>
</html>